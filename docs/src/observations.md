# Observation Dates

An "observation interval" (or "observation date") is the span of time associated with a
piece of input data used to generate a forecast or train a model.

For example, say it's `2016-08-11T09:00` and we want to predict the electrical load for
tomorrow at noon. This would make our target the interval between 11:00 and 12:00 on
2016-08-12, which we can abbreviate `(2016-08-12 HE12]`. We might want to look at the most
recent available electrical load for the same hour of the day (a dynamic offset which
would give us an observation of `(2016-08-10 HE12]`) and the most recent available
weather forecast for the two hours leading up to the target date (static offsets of -2 and
-1 hours, giving us observation intervals of `(2016-08-12 HE10]` and `(2016-08-12 HE11]`).

The `observations` function translates a set of offsets into the observation intervals of
the data that needs to be fetched from the S3DB.

## API

```@docs
observations
```

## Example

```@repl
using DateOffsets, TimeZones, Base.Dates
sim_now = ZonedDateTime(2016, 8, 11, 2, 30, tz"America/Winnipeg")
content_end = ZonedDateTime(2016, 8, 11, 2, tz"America/Winnipeg")
offsets = [LatestOffset(), StaticOffset(Day(1))]
s, t, o = observations(offsets, Horizon(), sim_now, content_end);
s
t
o
```

## FAQ

> As per the documentation above, the observation dates are returned in a matrix
> indexed row-wise by `sim_now` and `target` and column-wise by `offset`. So if the
> user passes in a vector of three `sim_nows`, a horizon that generates 24 target dates
> for each `sim_now`, and two offsets to apply, we'll end up with 72 rows and 2 columns.
>
> So we're essentially indexing our result by three vectors, but two of them are combined
> (so one index is `sim_now * target` and the other is `offset`). Wouldn't it be much
> simpler to index by those three vectors individually, and return a three-dimensional
> array?

Yes. It would also simplify the
[DataFeatures.jl](https://gitlab.invenia.ca/invenia/DataFeatures.jl) code quite a bit.

Unfortunately, in most cases we **can't actually know** how many target dates will be
generated by any given horizon. (In fact, that's why the `observations` function takes in
the horizon itself, rather than a set of targets.) Blame daylight saving time!

There are no perfect solutions. (This could also conceivably be solved by using a nullable
or sparse array.) But this solution has the advantage of having the observation date
matrix conform more closely to the eventual output format of the data being fetched from
S3DB (and being similar to the indexing scheme used in older versions of the prediction
system).

Given how this data is eventually used by DataFeatures.jl, it's possible that returning
the offset dates as a vector (alongside an additional index representing the offsets)
would be an even better solution. This change may be considered in the future.
